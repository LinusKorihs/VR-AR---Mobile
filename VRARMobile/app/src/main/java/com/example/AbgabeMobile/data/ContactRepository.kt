package com.example.AbgabeMobile.data

import android.content.ContentValues
import android.content.Context
import android.net.Uri
import android.os.Build
import android.os.Environment
import android.provider.MediaStore
import android.util.Log
import com.example.AbgabeMobile.network.KtorService
import com.example.AbgabeMobile.network.RandomUserResponse
import com.google.gson.Gson
import java.io.IOException
import java.io.OutputStream
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import kotlinx.coroutines.flow.Flow

class ContactRepository(
    private val contactDao: ContactDao,
    private val ktorService: KtorService
) {
    fun getAllContactsStream(): Flow<List<Contact>> = contactDao.getAll()
    fun getContactStream(id: Int): Flow<Contact?> = contactDao.getContact(id)

    suspend fun insertContact(contact: Contact): Long = contactDao.insert(contact)
    suspend fun deleteContact(contact: Contact) = contactDao.delete(contact)
    suspend fun updateContact(contact: Contact) = contactDao.update(contact)
    suspend fun deleteAllContacts() = contactDao.deleteAllContacts()

    suspend fun refreshContacts() {
        try {
            Log.d("ContactRepository", "Starting API call for contacts (RandomUser.me)...")
            val randomUserResponse: RandomUserResponse = ktorService.getRandomUsersFromApi()
            Log.d("ContactRepository", "API response received, count: ${randomUserResponse.results.size}")

            val contacts = randomUserResponse.results.map { result ->
                // Here we map the data from RandomUserResult to YOUR Contact object.
                // Ensure that all fields of the Contact data class are populated.
                Contact(
                    // id is auto-generated by Room, so no explicit assignment here
                    name = "${result.name.first} ${result.name.last}",
                    phone = result.phone,
                    email = result.email,
                    birthday = "", // RandomUser.me does not provide a direct birth date, set default value
                    street = result.location.street.name,
                    houseNr = result.location.street.number.toString(), // Convert Int to String
                    postcode = result.location.postcode ?: "", // Can be null from API, handle this
                    city = result.location.city,
                    imageRes = result.picture.thumbnail
                )
            }
            contactDao.deleteAllContacts() // Delete all old contacts
            contactDao.insertAll(contacts) // Add the new contacts
            Log.d("ContactRepository", "Contacts updated in database.")
        } catch (e: Exception) {
            Log.e("ContactRepository", "Error loading or mapping contacts from API", e)
            e.printStackTrace()
        }
    }

    suspend fun exportContactsToDownloads(context: Context): Boolean {
        val contacts = contactDao.getAllContactsList()
        if (contacts.isEmpty()) {
            Log.d("ContactRepository", "No contacts found to export.")
            return false
        }

        val jsonString = Gson().toJson(contacts)
        val fileName = "contacts_export_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())}.json"

        val resolver = context.contentResolver
        var outputStream: OutputStream? = null
        var uri: Uri? = null

        try {
            val contentValues = ContentValues().apply {
                put(MediaStore.MediaColumns.DISPLAY_NAME, fileName)
                put(MediaStore.MediaColumns.MIME_TYPE, "application/json")
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DOWNLOADS)
                }
            }

            uri = resolver.insert(MediaStore.Downloads.EXTERNAL_CONTENT_URI, contentValues)

            if (uri == null) {
                Log.e("ContactRepository", "Error: Could not create new MediaStore entry for downloads.")
                return false
            }

            outputStream = resolver.openOutputStream(uri)
            outputStream?.write(jsonString.toByteArray())
            outputStream?.flush()

            Log.d("ContactRepository", "Contacts successfully exported to Downloads as $fileName.")
            return true
        } catch (e: IOException) {
            Log.e("ContactRepository", "Error exporting contacts: ${e.message}", e)
            uri?.let {
                try {
                    resolver.delete(it, null, null)
                    Log.d("ContactRepository", "Partially created file deleted.")
                } catch (deleteEx: Exception) {
                    Log.e("ContactRepository", "Error deleting partial file: ${deleteEx.message}", deleteEx)
                }
            }
            return false
        } finally {
            outputStream?.close()
        }
    }
}